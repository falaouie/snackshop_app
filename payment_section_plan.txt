Phase 1: Create New Preset Widgets

Create USDPresetWidget class

Create a new file components/pos/usd_preset_widget.py
Implement a grid layout with 6 preset buttons ($1, $5, $10, $20, $50, $100)
Define signal: preset_selected = pyqtSignal(float) to emit chosen amount
Add a "USD Cash" button at the bottom that emits: payment_requested = pyqtSignal(float)


Create LBPPresetWidget class

Create a new file components/pos/lbp_preset_widget.py
Similar structure to USD widget with LBP presets (1000, 5000, 10000, 20000, 50000, 100000)
Define signal: preset_selected = pyqtSignal(float) for amount
Add a "LBP Cash" button at the bottom that emits: payment_requested = pyqtSignal(float)


Create PaymentMethodWidget class

Create a new file components/pos/payment_method_widget.py
Base class for Card and Other payment buttons
Include signal: payment_requested = pyqtSignal(str) for payment type


Create CardPaymentWidget and OtherPaymentWidget

Subclass from PaymentMethodWidget
Implement as full-size, styled buttons



Phase 2: Update Button and Layout Configurations

Add new button types and styles

Update button_definitions/types.py to include preset buttons
Create preset button configs in a new file if needed
Add styling info for preset buttons in styles/buttons.py


Add layout configuration

Update styles/layouts.py to include:

Preset button dimensions
Payment method button dimensions
Spacing for new layout


Update styling for payment sections in styles/pos.py



Phase 3: Modify TotalsWidget

Simplify TotalsWidget

Modify components/pos/totals_widget.py
Focus only on USD and LBP totals
Increase label sizes for better readability
Ensure proper styling for the simplified view



Phase 4: Integrate in POSView

Modify _create_intermediate_container method

Replace the current container with new layout
Instantiate new widgets:
pythonCopyself.usd_preset_widget = USDPresetWidget()
self.lbp_preset_widget = LBPPresetWidget()
self.card_payment_widget = CardPaymentWidget()
self.other_payment_widget = OtherPaymentWidget()

Connect signals:
pythonCopyself.usd_preset_widget.preset_selected.connect(self._handle_preset_selected)
self.usd_preset_widget.payment_requested.connect(lambda amount: self._process_payment("USD_CASH", amount))
self.lbp_preset_widget.preset_selected.connect(self._handle_preset_selected)
self.lbp_preset_widget.payment_requested.connect(lambda amount: self._process_payment("LBP_CASH", amount))
self.card_payment_widget.payment_requested.connect(lambda: self._process_payment("CARD"))
self.other_payment_widget.payment_requested.connect(lambda: self._process_payment("OTHER"))



Create new handler methods

Add method _handle_preset_selected(float amount) that:

Updates numpad display with selected preset amount
Sets pending_value to the selected amount


Add method _process_payment(str payment_type, float amount=None) that:

Checks if amount is provided or uses pending_value
Routes to appropriate payment processing method based on type
Handles view transitions for different payment methods




Remove/refactor PaymentButtonsWidget usage

Remove initialization of the old payment buttons widget
Remove related connections and handlers



Phase 5: Update Controllers and Services

Ensure controller methods support new payment flow

Update POSController methods to support the various payment types
Ensure proper validation for preset amounts
Add method for view transitions during payment processing


Add support in payment service

Update payment_service.py to handle the new payment methods



Phase 6: Testing and Refinement

Test each component

Test preset buttons functionality
Verify numpad integration with presets
Test payment method buttons


Test complete payment flow

Test end-to-end flow with various amounts and payment methods
Ensure error cases are handled properly


Refine UI/UX

Adjust sizes and spacing
Ensure visual clarity of the payment flow
Add appropriate visual feedback





Detailed Implementation Plan
Phase 1: Create New Widget Classes
1. Create USDPresetWidget
File: components/pos/usd_preset_widget.py
Copy- Implement QFrame subclass with grid layout
- Create 6 preset buttons ($1, $5, $10, $20, $50, $100)
- Add "USD Cash" payment button at bottom
- Signals: 
  - preset_selected(float) - emitted when preset clicked
  - payment_requested(float) - emitted when USD Cash button clicked
2. Create LBPPresetWidget
File: components/pos/lbp_preset_widget.py
Copy- Mirror USDPresetWidget structure
- Change presets to LBP values (1000, 5000, 10000, 20000, 50000, 100000)
- Add "LBP Cash" payment button at bottom
- Same signals as USDPresetWidget
3. Create PaymentOptionWidget (base class)
File: components/pos/payment_option_widget.py
Copy- Simple base class for Card/Other payment buttons
- Implement QFrame with single button or styled area
- Signal: payment_requested(str) - emitted when button clicked
4. Create Card/Other Payment Widgets
Files:

components/pos/card_payment_widget.py
components/pos/other_payment_widget.py

Copy- Subclass PaymentOptionWidget
- Customize styling and labels
- Pass appropriate payment types when emitting signals
Phase 2: Update Configuration and Styling
1. Update Layout Configuration
File: styles/layouts.py - Add in LayoutSizes class:
Copy- Add preset button dimensions:
  'preset_button_width': 140
  'preset_button_height': 35
  'preset_button_font_size': 14
  'preset_button_padding': 5
  'preset_button_spacing': 5
  
- Add payment action button dimensions:
  'payment_action_button_width': 140
  'payment_action_button_height': 40
  'payment_action_button_font_size': 15
  'payment_action_button_padding': 8
2. Update ButtonStyles
File: styles/buttons.py - Add new style methods:
Copy- Add get_preset_button_style(currency_type)
- Add get_payment_action_button_style(payment_type)
3. Update POSStyles
File: styles/pos.py - Add styles for new containers:
Copy- Add USD_PRESET_CONTAINER style
- Add LBP_PRESET_CONTAINER style
- Update PAYMENT_CONTAINER style
Phase 3: Modify TotalsWidget
File: components/pos/totals_widget.py
Copy- Simplify _create_amounts_section() to focus on clear USD/LBP display
- Increase font sizes in the TOTALS_FRAME style
- Use consistent styling and spacing
Phase 4: Integration in POSView
1. Modify _create_intermediate_container method
File: views/pos/pos_view.py
Copy- Replace current intermediate container layout
- Create layout with three columns: numpad, presets, payment options
- Instantiate new widget classes
- Connect signals with appropriate handlers
2. Add New Handler Methods
File: views/pos/pos_view.py
Copy- Add _handle_preset_selected(float amount) method
- Add _process_payment(str payment_type, float amount=None) method
- Update _on_payment_action to work with new components
3. Update Existing Code
File: views/pos/pos_view.py
Copy- Remove PaymentButtonsWidget usage
- Modify any methods that reference the old payment buttons
Phase 5: Implementation Steps (Order of Changes)

Create new widget classes in components/pos directory
Copy- Create base files with imports and class definitions
- Implement UI setup methods
- Add signal handling

Update configuration and style files
Copy- Add new button types if needed
- Add configuration parameters
- Add styling methods

Modify TotalsWidget
Copy- Simplify display
- Increase label sizes
- Maintain existing signals

Update POSView
Copy- Modify _create_intermediate_container method first
- Add handler methods
- Update existing payment processing logic

Test incrementally
Copy- Test each widget separately
- Test integration with numpad
- Test complete payment flow


Phase 6: Testing Strategy

Individual Components
Copy- Verify preset buttons show correct values
- Verify preset buttons emit correct signals
- Verify payment buttons emit correct signals

Integration
Copy- Test numpad input with payment processing
- Test preset selection with payment processing
- Test all payment methods (USD, LBP, Card, Other)

Edge Cases
Copy- Test with zero or invalid amounts
- Test with very large amounts
- Test error handling


This implementation plan provides a clear, step-by-step approach to modify your payment section while maintaining your existing architecture patterns. It focuses on completing the POS view's look and feel first, as you requested, rather than immediately refactoring for consistency.